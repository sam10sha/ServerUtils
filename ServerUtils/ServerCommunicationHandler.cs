using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.Net.Sockets;

#if DEBUG
using System.Diagnostics;
#endif

namespace ServerUtils
{
    public class ServerCommunicationHandler
    {
        /// <summary>
        /// The number of bytes to expect when transmitting the size
        /// value of a message
        /// </summary>
        private static int NUM_BYTES_MSG_SIZE_DESCRIPTOR = 4;

        /// <summary>
        /// A class containing the current stage of operation of the
        /// ClientManager.
        /// </summary>
        private class StateObject
        {
            /// <summary>
            /// An enumerator describing the current stage of the
            /// management cycle
            /// </summary>
            public enum CURRENTCONNECTIONSTAGE
            {
                CONNECTING_TO_SERVER,
                WAITING_CONNECT_TO_SERVER,
                SENDING_REQUEST_SIZE,
                WAITING_SEND_REQUEST_SIZE,
                SENDING_REQUEST,
                WAITING_SEND_REQUEST,
                RECEIVING_RESPONSE_SIZE,
                WAITING_RECEIVE_RESPONSE_SIZE,
                RECEIVING_RESPONSE,
                RETRYING_RECEIVE_RESPONSE,
                WAITING_RECEIVE_RESPONSE,
                ERROR,
                COMPLETE
            }

            /// <summary>
            /// The current stage of the management process.\n
            /// This is a shared variable. Usage of this
            /// variable must be carefully monitored
            /// </summary>
            internal CURRENTCONNECTIONSTAGE CurrentStage;

            /// <summary>
            /// A buffer to temporarily hold the size of the buffer.
            /// </summary>
            internal int TransmissionSize;

            /// <summary>
            /// A buffer to temporarily hold the number of bytes most
            /// recently transmitted.
            /// 
            /// Mainly intended for keeping track of the number of bytes
            /// transmitted while performing partial transactions.
            /// </summary>
            internal int TransmittedBytes;

            /// <summary>
            /// A buffer to temporarily hold data.
            /// </summary>
            internal byte[] Buffer;
        }


        /// <summary>
        /// The information about the server connection
        /// </summary>
        private IPEndPoint myIPEndPoint;

        /// <summary>
        /// The socket representing a server with which to communicate
        /// </summary>
        private Socket mySocket;

        /// <summary>
        /// A class containing the current state of operations of the
        /// ServerCommunicationHandler
        /// </summary>
        private StateObject StateObj;

        /// <summary>
        /// The bytes of the request to send to the server
        /// </summary>
        private byte[] myRequest;

        /// <summary>
        /// The bytes of the reply generated by the server in
        /// response to the request sent
        /// </summary>
        private byte[] myResponse;

        /// <summary>
        /// Initilizer for the ServerCommunicationHandler class.
        /// </summary>
        /// 
        /// <param name="IPAddr">
        /// The IP Address of the server to which to connect
        /// </param>
        /// <param name="PortNumber">
        /// The port number of the service on the server
        /// </param>
        /// <param name="Request">
        /// The bytes of the request to send to the server
        /// </param>
        public ServerCommunicationHandler(string IPAddr, int PortNumber, byte[] Request)
        {
            myIPEndPoint = new IPEndPoint(IPAddress.Parse(IPAddr), PortNumber);
            mySocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            StateObj = new StateObject();
            StateObj.TransmissionSize = 0;
            StateObj.Buffer = null;
            StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.CONNECTING_TO_SERVER;

            if (Request != null)
            {
                myRequest = Request;
            }
            else
            {
                myRequest = Encoding.ASCII.GetBytes("server_utils");
            }
            myResponse = null;
        }

        // Public properties

        /// <summary>
        /// A property describing whether or not the ServerCommunicationHandler's
        /// operations have halted. The ServerCommunicationHandler can halt in the
        /// event of success or failure.
        /// </summary>
        public bool Finished
        {
            get
            {
                bool Error = StateObj.CurrentStage == StateObject.CURRENTCONNECTIONSTAGE.ERROR;
                bool Completion = StateObj.CurrentStage == StateObject.CURRENTCONNECTIONSTAGE.COMPLETE;
                return Error || Completion;
            }
        }

        /// <summary>
        /// A property providing the server's reply, if available, in response to
        /// the request sent
        /// </summary>
        public byte[] Response
        {
            get
            {
                return myResponse;
            }
        }


        // Public member functions

        /// <summary>
        /// Procedure for communicating with a server. This function will block
        /// until either the operation is complete or the TerminationFlag has
        /// been set.
        /// </summary>
        /// 
        /// <param name="TerminationFlag">
        /// A reference to a termination flag that the ServerCommunicationHandler
        /// should monitor.
        /// </param>
        /// 
        /// <returns>
        /// True if the operation was successful in completing the task.
        /// False if the operation failed
        /// </returns>
        public bool CommunicateWithServer(ref bool TerminationFlag)
        {
            while (!TerminationFlag && !Finished)
            {
                /* The commented out code in this switch statement imply that
                 * the default branch should be taken and that the ServerCommunicationHandler
                 * should do nothing while in these states
                 */
                switch (StateObj.CurrentStage)
                {
                    case StateObject.CURRENTCONNECTIONSTAGE.CONNECTING_TO_SERVER:
                        ConnectToServer();
                        break;
                    /* case StateObject.CURRENTCONNECTIONSTAGE.WAITING_CONNECT_TO_SERVER:
                        break; */
                    case StateObject.CURRENTCONNECTIONSTAGE.SENDING_REQUEST_SIZE:
                        SendRequestSize();
                        break;
                    /* case StateObject.CURRENTCONNECTIONSTAGE.WAITING_SEND_REQUEST_SIZE:
                        break; */
                    case StateObject.CURRENTCONNECTIONSTAGE.SENDING_REQUEST:
                        SendRequest();
                        break;
                    /* case StateObject.CURRENTCONNECTIONSTAGE.WAITING_SEND_REQUEST:
                        break; */
                    case StateObject.CURRENTCONNECTIONSTAGE.RECEIVING_RESPONSE_SIZE:
                        ReceiveResponseSize();
                        break;
                    /* case StateObject.CURRENTCONNECTIONSTAGE.WAITING_RECEIVE_RESPONSE_SIZE:
                        break; */
                    case StateObject.CURRENTCONNECTIONSTAGE.RECEIVING_RESPONSE:
                        ReceiveResponse();
                        break;
                    case StateObject.CURRENTCONNECTIONSTAGE.RETRYING_RECEIVE_RESPONSE:
                        RetryReceiveResponse();
                        break;
                    /* case StateObject.CURRENTCONNECTIONSTAGE.WAITING_RECEIVE_RESPONSE:
                        break; */
                    default:
                        break;
                }
            }

            return StateObj.CurrentStage == StateObject.CURRENTCONNECTIONSTAGE.COMPLETE;
        }





        // Private member functions

        /// <summary>
        /// The operation to perform in order to connect to the server
        /// </summary>
        private void ConnectToServer()
        {
            // Shared variable StateObj.CurrentStage MUST NOT be modified after starting asynchronous operation
            StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.WAITING_CONNECT_TO_SERVER;
            mySocket.BeginConnect(myIPEndPoint, new AsyncCallback(AsyncConnectToServerCallback), StateObj);
        }
        /// <summary>
        /// The operation to perform when the ServerCommunicationHandler attempted to connect to the
        /// server
        /// </summary>
        /// 
        /// <param name="Result">
        /// An IAsyncResult that stores state information and any user defined data for this asynchronous operation.
        /// </param>
        private void AsyncConnectToServerCallback(IAsyncResult Result)
        {
            try
            {
                mySocket.EndConnect(Result);
                if (mySocket.Connected)
                {
                    StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.SENDING_REQUEST_SIZE;
                }
                else
                {
#if DEBUG
                    Debug.WriteLine("ServerCommunicationHandler[AsyncConnectToServerCallback]: Socket not connected");
#endif
                    StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
                }
            }
            catch (SocketException E)
            {
#if DEBUG
                Debug.WriteLine("ServerCommunicationHandler[AsyncConnectToServerCallback]: Error occurred trying to access the socket");
                Debug.WriteLine("ServerCommunicationHandler[AsyncConnectToServerCallback]: {0}", E.Message);
#endif
                StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
            }
            catch (ObjectDisposedException E)
            {
#if DEBUG
                Debug.WriteLine("ServerCommunicationHandler[AsyncConnectToServerCallback]: The socket has been closed");
                Debug.WriteLine("ServerCommunicationHandler[AsyncConnectToServerCallback]: {0}", E.Message);
#endif
                StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
            }
        }




        /// <summary>
        /// The operation to perform in order to send the size of the request to the server.
        /// </summary>
        private void SendRequestSize()
        {
            byte[] TransmissionSize = new byte[NUM_BYTES_MSG_SIZE_DESCRIPTOR];
            for (int i = 0; i < NUM_BYTES_MSG_SIZE_DESCRIPTOR; i++)
            {
                int ShiftLen = 8 * (NUM_BYTES_MSG_SIZE_DESCRIPTOR - i - 1);
                TransmissionSize[i] = (byte)(0xFF & (myRequest.Length >> ShiftLen));
            }
            // Shared variable StateObj.CurrentStage MUST NOT be modified after starting asynchronous operation
            StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.WAITING_SEND_REQUEST_SIZE;
            mySocket.BeginSend(TransmissionSize, 0, NUM_BYTES_MSG_SIZE_DESCRIPTOR, SocketFlags.None, new AsyncCallback(AsyncSendSizeToServerCallback), StateObj);
        }
        /// <summary>
        /// The operation to perform when the ServerCommunicationhandler has sent the
        /// request size to the server
        /// </summary>
        /// 
        /// <param name="Result">
        /// An IAsyncResult that stores state information and any user defined data for this asynchronous operation.
        /// </param>
        private void AsyncSendSizeToServerCallback(IAsyncResult Result)
        {
            try
            {
                int NumBytesTransmitted = mySocket.EndSend(Result);
                if (NumBytesTransmitted == NUM_BYTES_MSG_SIZE_DESCRIPTOR)
                {
                    StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.SENDING_REQUEST;
                }
                else
                {
#if DEBUG
                    Debug.WriteLine("ServerCommunicationHandler[AsyncSendSizeToServerCallback]: Invalid number of bytes of size transmitted");
#endif
                    StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
                }
            }
            catch (SocketException E)
            {
#if DEBUG
                Debug.WriteLine("ServerCommunicationHandler[AsyncSendSizeToServerCallback]: Error occurred trying to access the socket");
                Debug.WriteLine("ServerCommunicationHandler[AsyncSendSizeToServerCallback]: {0}", E.Message);
#endif
                StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
            }
            catch (ObjectDisposedException E)
            {
#if DEBUG
                Debug.WriteLine("ServerCommunicationHandler[AsyncSendSizeToServerCallback]: The socket has been closed");
                Debug.WriteLine("ServerCommunicationHandler[AsyncSendSizeToServerCallback]: {0}", E.Message);
#endif
                StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
            }
        }




        /// <summary>
        /// The operation to perform in order to send the request to the server.
        /// </summary>
        private void SendRequest()
        {
            // Shared variable StateObj.CurrentStage MUST NOT be modified after starting asynchronous operation
            StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.WAITING_SEND_REQUEST;
            mySocket.BeginSend(myRequest, 0, myRequest.Length, SocketFlags.None, new AsyncCallback(AsyncSendRequestCallback), StateObj);
        }
        /// <summary>
        /// The operation to perform when the ServerCommunicationhandler has sent the
        /// request to the server
        /// </summary>
        /// 
        /// <param name="Result">
        /// An IAsyncResult that stores state information and any user defined data for this asynchronous operation.
        /// </param>
        private void AsyncSendRequestCallback(IAsyncResult Result)
        {
            try
            {
                int NumBytesTransmitted = mySocket.EndSend(Result);
                if (NumBytesTransmitted == myRequest.Length)
                {
                    StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.RECEIVING_RESPONSE_SIZE;
                }
                else
                {
#if DEBUG
                    Debug.WriteLine("ServerCommunicationHandler[AsyncSendRequestCallback]: Invalid number of bytes transmitted");
#endif
                    StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
                }
            }
            catch (SocketException E)
            {
#if DEBUG
                Debug.WriteLine("ServerCommunicationHandler[AsyncSendRequestCallback]: Error occurred trying to access the socket");
                Debug.WriteLine("ServerCommunicationHandler[AsyncSendRequestCallback]: {0}", E.Message);
#endif
                StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
            }
            catch (ObjectDisposedException E)
            {

#if DEBUG
                Debug.WriteLine("ServerCommunicationHandler[AsyncSendRequestCallback]: The socket has been closed");
                Debug.WriteLine("ServerCommunicationHandler[AsyncSendRequestCallback]: {0}", E.Message);
#endif
                StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
            }
        }




        /// <summary>
        /// The operation to perform in order to receive the response size from the server.
        /// </summary>
        private void ReceiveResponseSize()
        {
            StateObj.Buffer = new byte[NUM_BYTES_MSG_SIZE_DESCRIPTOR];

            // Shared variable StateObj.CurrentStage MUST NOT be modified after starting asynchronous operation
            StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.WAITING_RECEIVE_RESPONSE_SIZE;
            mySocket.BeginReceive(StateObj.Buffer, 0, NUM_BYTES_MSG_SIZE_DESCRIPTOR, SocketFlags.None, new AsyncCallback(AsyncReadResponseSizeCallback), StateObj);
        }
        /// <summary>
        /// The operation to perform when the ServerCommunicationhandler has received the
        /// response size from the server
        /// </summary>
        /// 
        /// <param name="Result">
        /// An IAsyncResult that stores state information and any user defined data for this asynchronous operation.
        /// </param>
        private void AsyncReadResponseSizeCallback(IAsyncResult Result)
        {
            try
            {
                int NumBytesReceived = mySocket.EndReceive(Result);
                if (NumBytesReceived == NUM_BYTES_MSG_SIZE_DESCRIPTOR)
                {
                    StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.RECEIVING_RESPONSE;
                }
                else
                {
#if DEBUG
                    Debug.WriteLine("ServerCommunicationHandler[AsyncReadResponseSizeCallback]: Invalid number of bytes received");
#endif
                    StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
                }
            }
            catch (SocketException E)
            {
#if DEBUG
                Debug.WriteLine("ServerCommunicationHandler[AsyncReadResponseSizeCallback]: Error occurred trying to access the socket");
                Debug.WriteLine("ServerCommunicationHandler[AsyncReadResponseSizeCallback]: {0}", E.Message);
#endif
                StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
            }
            catch (ObjectDisposedException E)
            {
#if DEBUG
                Debug.WriteLine("ServerCommunicationHandler[AsyncReadResponseSizeCallback]: The socket has been closed");
                Debug.WriteLine("ServerCommunicationHandler[AsyncReadResponseSizeCallback]: {0}", E.Message);
#endif
                StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
            }
        }




        /// <summary>
        /// The operation to perform in order to receive the response from the server.
        /// </summary>
        private void ReceiveResponse()
        {
            StateObj.TransmissionSize = 0;
            for (int i = 0; i < NUM_BYTES_MSG_SIZE_DESCRIPTOR; i++)
            {
                int ShiftLen = 8 * (NUM_BYTES_MSG_SIZE_DESCRIPTOR - i - 1);
                StateObj.TransmissionSize += (int)((0xFFFFFFFF & StateObj.Buffer[i]) << ShiftLen);
            }
            StateObj.Buffer = new byte[StateObj.TransmissionSize];

            // Shared variable StateObj.CurrentStage MUST NOT be modified after starting asynchronous operation
            StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.WAITING_RECEIVE_RESPONSE;
            mySocket.BeginReceive(StateObj.Buffer, 0, StateObj.TransmissionSize, SocketFlags.None, new AsyncCallback(AsyncReadResponseCallback), StateObj);
        }
        /// <summary>
        /// The operation to perform when the ServerCommunicationhandler has received the
        /// response from the server
        /// </summary>
        /// 
        /// <param name="Result">
        /// An IAsyncResult that stores state information and any user defined data for this asynchronous operation.
        /// </param>
        private void AsyncReadResponseCallback(IAsyncResult Result)
        {
            try
            {
                int NumBytesReceived = mySocket.EndReceive(Result);
                if (NumBytesReceived >= StateObj.TransmissionSize)
                {
                    myResponse = StateObj.Buffer;
                    StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.COMPLETE;
                }
                else
                {
                    StateObj.TransmittedBytes = NumBytesReceived;
                    StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.RETRYING_RECEIVE_RESPONSE;
                }
            }
            catch (SocketException E)
            {
#if DEBUG
                Debug.WriteLine("ServerCommunicationHandler[AsyncReadResponseCallback]: Error occurred trying to access the socket");
                Debug.WriteLine("ServerCommunicationHandler[AsyncReadResponseCallback]: {0}", E.Message);
#endif
                StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
            }
            catch (ObjectDisposedException E)
            {
#if DEBUG
                Debug.WriteLine("ServerCommunicationHandler[AsyncReadResponseCallback]: The socket has been closed");
                Debug.WriteLine("ServerCommunicationHandler[AsyncReadResponseCallback]: {0}", E.Message);
#endif
                StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
            }
        }




        /// <summary>
        /// The operation to perform in order to try receiving more bytes of the response
        /// from the server.
        /// </summary>
        private void RetryReceiveResponse()
        {
            // Shared variable StateObj.CurrentStage MUST NOT be modified after starting asynchronous operation
            StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.WAITING_RECEIVE_RESPONSE;
            mySocket.BeginReceive(StateObj.Buffer,
                                StateObj.TransmittedBytes,
                                StateObj.TransmissionSize - StateObj.TransmittedBytes,
                                SocketFlags.None,
                                new AsyncCallback(AsyncRetryReceiveResponseCallback),
                                StateObj);
        }
        /// <summary>
        /// The operation to perform when the ServerCommunicationhandler has received more bytes
        /// from the response from the server
        /// </summary>
        /// 
        /// <param name="Result">
        /// An IAsyncResult that stores state information and any user defined data for this asynchronous operation.
        /// </param>
        private void AsyncRetryReceiveResponseCallback(IAsyncResult Result)
        {
            try
            {
                int NumBytesReceived = mySocket.EndReceive(Result);
                StateObj.TransmittedBytes += NumBytesReceived;

                if (StateObj.TransmittedBytes >= StateObj.TransmissionSize)
                {
                    myResponse = StateObj.Buffer;
                    StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.COMPLETE;
                }
                else
                {
                    StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.RETRYING_RECEIVE_RESPONSE;
                }
            }
            catch (SocketException E)
            {
#if DEBUG
                Debug.WriteLine("ServerCommunicationHandler[AsyncRetryReceiveResponseCallback]: Error occurred trying to access the socket");
                Debug.WriteLine("ServerCommunicationHandler[AsyncRetryReceiveResponseCallback]: {0}", E.Message);
#endif
                StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
            }
            catch (ObjectDisposedException E)
            {
#if DEBUG
                Debug.WriteLine("ServerCommunicationHandler[AsyncRetryReceiveResponseCallback]: The socket has been closed");
                Debug.WriteLine("ServerCommunicationHandler[AsyncRetryReceiveResponseCallback]: {0}", E.Message);
#endif
                StateObj.CurrentStage = StateObject.CURRENTCONNECTIONSTAGE.ERROR;
            }
        }
    }
}
